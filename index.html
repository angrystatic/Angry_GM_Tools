<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien RPG Map Generator Prototype v4 (Data Fix)</title> <style>
        /* --- Basic Body & Control Styles --- */
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #c0c0c0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 {
            color: #4CAF50;
            text-shadow: 0 0 5px #4CAF50;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            margin-bottom: 30px;
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }
        .controls > div { display: flex; align-items: center; gap: 5px; }
        label { color: #a0a0a0; white-space: nowrap; }
        select, button { padding: 8px 12px; background-color: #333; color: #c0c0c0; border: 1px solid #555; border-radius: 3px; font-family: inherit; cursor: pointer; }
        button:hover { background-color: #444; border-color: #777; }

        /* --- Map Container --- */
        #map-container {
            width: 85%;
            max-width: 1000px;
            min-height: 600px;
            background-color: #0a0f0a;
            border: 2px solid #3a5a3a;
            position: relative; /* Crucial for positioning children */
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 15px;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
            box-sizing: border-box;
        }

        /* --- SVG Overlay for Connectors --- */
        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            /* Width/Height set dynamically by JS to match content */
            z-index: 1;
            pointer-events: none;
        }

        /* --- Connector Line Styles --- */
        .connector-line {
            stroke-linecap: round;
        }
        .connector-corridor {
            stroke: rgba(76, 175, 80, 0.6); /* Greenish corridor */
            stroke-width: 4px;
        }
        .connector-vent {
            stroke: rgba(100, 100, 150, 0.7); /* Bluish vent */
            stroke-width: 2px;
            stroke-dasharray: 5, 5; /* Dashed line for vents */
        }


        /* --- Zone Styling --- */
        .zone {
            position: absolute;
            background-color: rgba(50, 70, 50, 0.7);
            border: 1px solid #4CAF50;
            color: #e0e0e0;
            padding: 10px;
            text-align: center;
            width: 120px;
            min-height: 50px;
            height: auto;
            border-radius: 3px;
            font-size: 0.85em;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
            transition: all 0.5s ease-out;
            box-sizing: border-box;
            transform: translate(-50%, -50%);
            z-index: 2; /* Ensure zones are above SVG */
            pointer-events: auto; /* Make zones interactive */
        }
        .zone-major { width: 160px; min-height: 65px; font-weight: bold; border-width: 2px; padding: 12px; z-index: 5; }
        .zone-command { background-color: rgba(70, 90, 70, 0.8); border-color: #6acF70;}
        .zone-medbay { background-color: rgba(50, 50, 90, 0.7); border-color: #6a6aff;}
        .zone-engineering { background-color: rgba(90, 70, 50, 0.7); border-color: #ffaa6a;}
        .zone-danger { border-color: #ff4444; color: #ffaaaa; background-color: rgba(90, 50, 50, 0.7); }

        /* --- Legend Styles --- */
        #legend {
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px 15px;
            margin-top: 30px;
            width: 85%;
            max-width: 1000px;
            box-sizing: border-box;
        }
        #legend h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #a0a0a0;
            text-align: center;
        }
        #legend ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap */
            gap: 10px 20px; /* Row and column gap */
            justify-content: center; /* Center items */
        }
        #legend li {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between symbol and text */
            font-size: 0.9em;
        }
        .legend-box {
            display: inline-block;
            width: 20px;
            height: 15px;
            border: 1px solid #ccc; /* Base border */
            vertical-align: middle;
        }
        .legend-line {
            display: inline-block;
            width: 25px;
            height: 4px; /* Match corridor thickness */
            border: none;
            vertical-align: middle;
        }
        /* Style examples to match map elements */
        .zone-normal-example { background-color: rgba(50, 70, 50, 0.7); border-color: #4CAF50; }
        .zone-major-example { background-color: rgba(50, 70, 50, 0.7); border-color: #4CAF50; border-width: 2px; /* Simulate major look */ }
        .zone-command-example { background-color: rgba(70, 90, 70, 0.8); border-color: #6acF70; }
        .zone-medbay-example { background-color: rgba(50, 50, 90, 0.7); border-color: #6a6aff; }
        .zone-engineering-example { background-color: rgba(90, 70, 50, 0.7); border-color: #ffaa6a; }
        .zone-danger-example { background-color: rgba(90, 50, 50, 0.7); border-color: #ff4444; }
        .connector-corridor-example { background-color: rgba(76, 175, 80, 0.6); height: 4px; }
        .connector-vent-example {
            height: 2px;
            background: repeating-linear-gradient( /* Simulate dashed line */
                90deg,
                rgba(100, 100, 150, 0.7),
                rgba(100, 100, 150, 0.7) 5px,
                transparent 5px,
                transparent 10px
            );
        }

    </style>
</head>
<body>

    <h1>Alien RPG Map Generator (Prototype v4)</h1> <div class="controls">
        <div> <label for="facility-type">Type:</label> <select id="facility-type"> <option value="Colony">Colony</option> <option value="Station">Station</option> <option value="Ship">Ship</option> <option value="Outpost">Military/Science Outpost</option> <option value="Derelict">Derelict (Random Mix)</option> </select> </div>
        <div> <label for="facility-size">Size:</label> <select id="facility-size"> <option value="Small">Small</option> <option value="Medium" selected>Medium</option> <option value="Large">Large</option> </select> </div>
        <div> <label for="layout-style">Layout:</label> <select id="layout-style"> <option value="Grid">Grid</option> <option value="HubAndSpoke">Hub-and-Spoke</option> <option value="Linear">Linear</option> </select> </div>
        <button id="generate-button">Generate Map</button>
        </div>

    <div id="map-container">
        </div>

    <div id="legend">
        <h4>Legend</h4>
        <ul>
            <li><span class="legend-box zone-normal-example"></span> Normal Zone</li>
            <li><span class="legend-box zone-major-example"></span> Major Zone</li>
            <li><span class="legend-line connector-corridor-example"></span> Corridor</li>
            <li><span class="legend-line connector-vent-example"></span> Vent / Duct</li>
            <li><span class="legend-box zone-command-example"></span> Command/Ops</li>
            <li><span class="legend-box zone-medbay-example"></span> Medical</li>
            <li><span class="legend-box zone-engineering-example"></span> Engineering/Tech</li>
            <li><span class="legend-box zone-danger-example"></span> Damaged/Hazard</li>
        </ul>
    </div>


    <script>
        // --- DOM Elements ---
        let facilityTypeSelect, facilitySizeSelect, layoutStyleSelect, generateButton, mapContainer;
        try {
            facilityTypeSelect = document.getElementById('facility-type');
            facilitySizeSelect = document.getElementById('facility-size');
            layoutStyleSelect = document.getElementById('layout-style');
            generateButton = document.getElementById('generate-button');
            mapContainer = document.getElementById('map-container');

            if (!facilityTypeSelect || !facilitySizeSelect || !layoutStyleSelect || !generateButton || !mapContainer) {
                throw new Error("One or more essential HTML elements not found!");
            }
            console.log("DOM elements obtained successfully.");
        } catch (error) {
            console.error("FATAL ERROR getting DOM elements:", error);
            const body = document.querySelector('body');
            if (body) { body.innerHTML = `<p style="color:red; font-size: 1.2em; padding: 20px;">FATAL ERROR: Could not initialize page elements. ${error.message}</p>`; }
        }


        // --- Data Definitions (SINGLE, CORRECTED DEFINITION) ---
        const coreZones = {
             Colony: ['Command/Admin', 'Habitation Blocks', 'Medbay', 'Engineering (Power/Life Support)', 'Atmosphere Processing', 'Cargo/Industrial Zone', 'Security Post', 'Main Communications'],
             Station: ['Command Center', 'Habitation Ring', 'Medbay', 'Engineering Core', 'Docking Bay(s)', 'Cargo Hold', 'Science Labs', 'Security Hub', 'Life Support Center'],
             Ship: ['Bridge', 'Crew Quarters', 'Medbay', 'Engineering Deck', 'Cargo Bay', 'Cryosleep Chamber', 'Airlock Section', 'Primary Life Support'],
             Outpost: ['Operations Center (Ops)', 'Barracks/Quarters', 'Small Infirmary', 'Generator Room', 'Armory/Storage', 'Perimeter Access Point', 'Comms Relay', 'Basic Life Support'],
             Derelict: ['Damaged Bridge', 'Breached Habitation', 'Offline Engineering', 'Flooded Cargo Bay', 'Makeshift Medbay', 'Mysterious Lab', 'Compromised Airlock', 'Nest Area', 'Failing Life Support']
        };
        const optionalZones = {
             Colony: ['Mining Control', 'Hydroponics', 'Vehicle Bay', 'Recreation Zone', 'Marketplace', 'Waste Recycling', 'Shuttle Pad', 'Large Mess Hall', 'Education Center', 'Maintenance Tunnels Access'],
             Station: ['Customs/Security Checkpoint', 'Observation Deck', 'Zero-G Gym', 'Shuttle Bay', 'Long-Range Comms', 'Waste Disposal', 'Manufacturing Area', 'Trade Hub Market', 'Bar/Cantina', 'Ventilation Hub'],
             Ship: ['Science Scanner Room', 'Observation Pod', 'Shuttle Bay', 'Probe Launch Tube', 'Brig', 'Vehicle Bay (Large Ship)', 'Auxiliary Control', 'Ships Mess', 'Small Rec Room', 'Service Ducts Access'],
             Outpost: ['Vehicle Maintenance Bay', 'Small Lab', 'Holding Cells', 'Watchtower', 'Underground Access', 'Landing Zone', 'Basic Mess Area', 'Perimeter Vents'],
             Derelict: ['Ancient Ruins Section', 'Fungal Garden', 'Trapped Shuttle', 'Wreckage Field Access', 'Hidden Stash', 'Queen Chamber', 'Barricaded Area', 'Makeshift Shrine', 'Collapsed Tunnel']
        };
        const majorZoneKeywords = ['Habitation', 'Command', 'Bridge', 'Engineering', 'Cargo', 'Docking', 'Ops', 'Industrial', 'Ring', 'Deck', 'Blocks', 'Center', 'Core', 'Bay(s)'];
        const habitationKeywords = ['Habitation', 'Quarters', 'Barracks', 'Ring', 'Cryosleep'];
        const amenityKeywords = ['Mess Hall', 'Mess Area', 'Canteen', 'Recreation', 'Marketplace', 'Gym', 'Bar', 'Cantina', 'Observation Deck', 'Chapel', 'Shrine', 'Education Center', 'Rec Room', 'Trade Hub'];
        const criticalFunctionKeywords = ['Command', 'Bridge', 'Ops', 'Engineering', 'Power', 'Generator', 'Life Support', 'Atmosphere', 'Comms', 'Communications'];
        const technicalKeywords = ['Engineering', 'Generator', 'Power', 'Life Support', 'Atmosphere', 'Maintenance', 'Worksh', 'Lab', 'Scanner', 'Server', 'Comms', 'Technical', 'Ventilation'];
        const securityKeywords = ['Security', 'Armory', 'Brig', 'Checkpoint', 'Holding Cells'];

        // --- Global Array to Store Placed Zone Data ---
        let placedZoneData = [];

        // --- Event Listeners ---
        if (generateButton) {
            generateButton.addEventListener('click', generateMap);
        }
        // Removed listener for exportButton

        // --- Helper Functions for Zone Adjustment ---
        function containsZoneType(zoneList, keywords) { return zoneList.some(zone => keywords.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase()))); }
        function findZoneByType(zoneList, keywords) { return zoneList.find(zone => keywords.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase()))); }
        function getRandomNewZoneOfType(targetList, zonePool, keywords) { const available = zonePool.filter(zone => !targetList.includes(zone) && keywords.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase())) ); if (available.length === 0) return null; return available[Math.floor(Math.random() * available.length)]; }
        function getRandomNewZoneNotOfType(targetList, zonePool, keywordsToAvoid) { const available = zonePool.filter(zone => !targetList.includes(zone) && !keywordsToAvoid.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase())) ); if (available.length === 0) { const fallbackPool = zonePool.filter(zone => !targetList.includes(zone)); return fallbackPool.length > 0 ? fallbackPool[Math.floor(Math.random() * fallbackPool.length)] : null; } return available[Math.floor(Math.random() * available.length)]; }

        // --- Zone Adjustment Logic ---
        function adjustZonesForSizeAndType(initialZones, baseZonePool, optionalZonePool, size, type) {
             console.log("Adjusting zones. Initial:", initialZones);
            let adjustedZones = [...initialZones]; const allZonePool = [...new Set([...baseZonePool, ...optionalZonePool])];
            if (!containsZoneType(adjustedZones, habitationKeywords)) { const newHab = getRandomNewZoneOfType(adjustedZones, allZonePool, habitationKeywords); if (newHab) { console.log(`Adding Habitation: ${newHab}`); adjustedZones.push(newHab); } else { console.error(`CRITICAL - Could not find Habitation zone!`); } }
            let amenityCount = adjustedZones.filter(zone => amenityKeywords.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase()))).length; const luxuryAmenities = ['Marketplace', 'Zero-G Gym', 'Observation Deck', 'Trade Hub', 'Bar/Cantina', 'Cinema', 'Education Center'];
            if (size === 'Small') { const maxAmenities = (type === 'Station' || type === 'Colony') ? 1 : 0; let removedCount = 0; while(amenityCount > maxAmenities && removedCount < 5) { let removed = false; const luxIdx = adjustedZones.findIndex(zone => luxuryAmenities.some(lux => zone.toLowerCase().includes(lux.toLowerCase()))); if(luxIdx !== -1) { console.log(`Small: Removing luxury amenity: ${adjustedZones[luxIdx]}`); adjustedZones.splice(luxIdx, 1); amenityCount--; removed = true; } else { const otherAmenityIdx = adjustedZones.findIndex(zone => amenityKeywords.some(keyword => zone.toLowerCase().includes(keyword.toLowerCase())) && !zone.toLowerCase().includes("mess")); if(otherAmenityIdx !== -1) { console.log(`Small: Removing excess amenity: ${adjustedZones[otherAmenityIdx]}`); adjustedZones.splice(otherAmenityIdx, 1); amenityCount--; removed = true; } } if(!removed) break; removedCount++; } }
            else if (size === 'Medium' && amenityCount === 0) { const newAmenity = getRandomNewZoneOfType(adjustedZones, optionalZonePool, amenityKeywords); if (newAmenity) { console.log(`Medium: Adding amenity: ${newAmenity}`); adjustedZones.push(newAmenity); amenityCount++; } else { console.warn("Medium: Could not find amenity zone."); } }
            else if (size === 'Large') { const targetAmenities = (type === 'Colony' || type === 'Station') ? 3 : 2; let addedCount = 0; while (amenityCount < targetAmenities && addedCount < 3) { const newAmenity = getRandomNewZoneOfType(adjustedZones, optionalZonePool, amenityKeywords); if (newAmenity) { console.log(`Large: Adding amenity: ${newAmenity}`); adjustedZones.push(newAmenity); amenityCount++; addedCount++; } else { console.warn("Large: Could not find more amenities."); break; } } }
            const criticalChecks = { 'Command': ['Command', 'Bridge', 'Ops'], 'Engineering': ['Engineering', 'Power', 'Generator'], 'Life Support': ['Life Support', 'Atmosphere'] };
            for(const funcName in criticalChecks) { if (!containsZoneType(adjustedZones, criticalChecks[funcName])) { const newCritical = getRandomNewZoneOfType(adjustedZones, baseZonePool, criticalChecks[funcName]) || getRandomNewZoneOfType(adjustedZones, allZonePool, criticalChecks[funcName]); if(newCritical) { console.warn(`Adding missing critical ${funcName}: ${newCritical}`); adjustedZones.push(newCritical); } else { console.error(`CRITICAL FAILURE: Could not find ${funcName}-type zone!`); } } }
            const finalUniqueZones = [...new Set(adjustedZones)]; console.log("Adjustment complete. Final zones:", finalUniqueZones); return finalUniqueZones;
        }

        // --- Main Generation Function ---
        function generateMap() {
            console.log("--- generateMap START ---");
            if (!mapContainer) { console.error("generateMap cannot run: mapContainer not found."); return; }
            try {
                const type = facilityTypeSelect.value; const size = facilitySizeSelect.value; const layoutStyle = layoutStyleSelect.value;
                mapContainer.innerHTML = '';
                const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); svgElement.setAttribute('id', 'connector-svg'); mapContainer.appendChild(svgElement);
                placedZoneData = [];
                console.log(`Generating map for Type: ${type}, Size: ${size}, Layout: ${layoutStyle}`);
                let effectiveType = type; if (!coreZones[effectiveType] || !optionalZones[effectiveType]) { effectiveType = 'Derelict'; }
                const baseZonePool = coreZones[effectiveType] ? [...coreZones[effectiveType]] : []; const optionalZonePool = optionalZones[effectiveType] ? [...optionalZones[effectiveType]] : [];
                let numCoreTarget, numOptionalTarget; switch (size) { case 'Small': numCoreTarget = Math.min(baseZonePool.length, Math.floor(Math.random() * 2) + 2); numOptionalTarget = Math.min(optionalZonePool.length, Math.floor(Math.random() * 2) + 1); break; case 'Large': numCoreTarget = Math.min(baseZonePool.length, Math.floor(Math.random() * 2) + 4); numOptionalTarget = Math.min(optionalZonePool.length, Math.floor(Math.random() * 3) + 3); break; case 'Medium': default: numCoreTarget = Math.min(baseZonePool.length, Math.floor(Math.random() * 2) + 3); numOptionalTarget = Math.min(optionalZonePool.length, Math.floor(Math.random() * 3) + 2); break; }
                console.log(`Target counts - Core: ${numCoreTarget}, Optional: ${numOptionalTarget}`);
                let initialSelectedZones = selectRandomElements(baseZonePool, numCoreTarget); initialSelectedZones = initialSelectedZones.concat(selectRandomElements(optionalZonePool, numOptionalTarget));
                let finalSelectedZones = adjustZonesForSizeAndType( initialSelectedZones, baseZonePool, optionalZonePool, size, effectiveType );
                if (finalSelectedZones.length === 0) { console.warn("No zones selected."); mapContainer.innerHTML = '<p style="color: yellow; padding: 20px;">No zones generated.</p>'; return; }
                const containerWidth = mapContainer.offsetWidth; const containerHeight = mapContainer.offsetHeight; console.log("Container dimensions:", containerWidth, containerHeight);
                if (containerWidth <= 0 || containerHeight <= 0) { console.error("Container size issue."); mapContainer.innerHTML = '<p style="color: red; padding: 20px;">Error: Container size issue.</p>'; return; }
                const layoutOptions = { size: size };
                console.log(`Calling layout function: ${layoutStyle}`);
                switch (layoutStyle) { case 'HubAndSpoke': layoutHubAndSpoke(finalSelectedZones, containerWidth, containerHeight, layoutOptions); break; case 'Linear': layoutLinear(finalSelectedZones, containerWidth, containerHeight, layoutOptions); break; case 'Grid': default: layoutGrid(finalSelectedZones, containerWidth, containerHeight, layoutOptions); break; }
                 console.log("Layout complete. Placed zones data length:", placedZoneData.length);
                if (placedZoneData.length > 0) { console.log("Appending zone elements to DOM..."); placedZoneData.forEach(zoneInfo => { if (zoneInfo && zoneInfo.element instanceof Node) { mapContainer.appendChild(zoneInfo.element); } else { console.error("Invalid element found in placedZoneData for:", zoneInfo ? zoneInfo.name : 'unknown'); } }); } else { console.warn("No zone data populated."); }
                 console.log("Calling drawConnections..."); drawConnections(placedZoneData, layoutStyle, svgElement);
                console.log("--- generateMap END ---");
            } catch (error) { console.error("!!! Error during map generation:", error); mapContainer.innerHTML = `<p style="color: red; padding: 20px;">An error occurred: ${error.message}. Check console (F12).</p>`; }
        }

        // --- Helper: Create Zone Div ---
        function createZoneElement(zoneName) {
            const zoneDiv = document.createElement('div'); zoneDiv.classList.add('zone'); zoneDiv.textContent = zoneName;
            const lowerZoneName = zoneName.toLowerCase(); if (majorZoneKeywords.some(keyword => lowerZoneName.includes(keyword.toLowerCase()))) { zoneDiv.classList.add('zone-major'); }
            if (lowerZoneName.includes('command') || lowerZoneName.includes('bridge') || lowerZoneName.includes('ops')) { zoneDiv.classList.add('zone-command'); } else if (lowerZoneName.includes('medbay') || lowerZoneName.includes('infirmary')) { zoneDiv.classList.add('zone-medbay'); } else if (lowerZoneName.includes('engineering') || lowerZoneName.includes('generator') || lowerZoneName.includes('power')) { zoneDiv.classList.add('zone-engineering'); } else if (lowerZoneName.includes('damaged') || lowerZoneName.includes('breached') || lowerZoneName.includes('nest') || lowerZoneName.includes('offline') || lowerZoneName.includes('flooded') || lowerZoneName.includes('compromised')) { zoneDiv.classList.add('zone-danger'); } return zoneDiv;
        }

        // --- Layout Algorithms (Populate placedZoneData) ---
        function layoutGrid(zones, containerWidth, containerHeight, options) {
            console.log("layoutGrid running...");
            const sizeFactor = options.size === 'Large' ? 1.05 : (options.size === 'Small' ? 0.95 : 1.0);
            const numZones = zones.length; if (numZones === 0) return;
            let cols = Math.ceil(Math.sqrt(numZones * (containerWidth / containerHeight)));
            if (numZones <= 4) cols = Math.min(numZones, 2); else if (numZones <= 6) cols = 3; else if (numZones <= 9) cols = 3; else cols = Math.max(3, Math.ceil(numZones / 3));
            const rows = Math.ceil(numZones / cols);
            const cellWidth = (containerWidth / cols); const cellHeight = (containerHeight / rows);
            const paddingX = cellWidth * 0.15 * sizeFactor; const paddingY = cellHeight * 0.15 * sizeFactor;
            const jitter = 0.15;
            zones.forEach((zoneName, index) => {
                const zoneDiv = createZoneElement(zoneName); const isMajor = zoneDiv.classList.contains('zone-major');
                const elementWidth = isMajor ? 160 : 120; const elementHeight = isMajor ? 65 : 50;
                const gridRow = Math.floor(index / cols); const gridCol = index % cols;
                const targetX = (gridCol * cellWidth) + (cellWidth / 2) + (Math.random() - 0.5) * cellWidth * jitter;
                const targetY = (gridRow * cellHeight) + (cellHeight / 2) + (Math.random() - 0.5) * cellHeight * jitter;
                const finalX = Math.max(elementWidth / 2 + paddingX / 2, Math.min(containerWidth - elementWidth / 2 - paddingX / 2, targetX));
                const finalY = Math.max(elementHeight / 2 + paddingY / 2, Math.min(containerHeight - elementHeight / 2 - 15, targetY));
                zoneDiv.style.left = `${finalX}px`; zoneDiv.style.top = `${finalY}px`;
                placedZoneData.push({ name: zoneName, element: zoneDiv, x: finalX, y: finalY, row: gridRow, col: gridCol });
            });
            console.log("layoutGrid finished.");
        }
        function layoutHubAndSpoke(zones, containerWidth, containerHeight, options) {
            console.log("layoutHubAndSpoke running...");
             const sizeFactor = options.size === 'Large' ? 1.15 : (options.size === 'Small' ? 0.85 : 1.0);
             const numZones = zones.length; if (numZones === 0) return;
             const centerX = containerWidth / 2; const centerY = containerHeight / 2;
             let centralZoneIndex = zones.findIndex(name => /command|bridge|ops|hub|core/i.test(name));
             if (centralZoneIndex === -1 || centralZoneIndex >= zones.length) centralZoneIndex = 0;
             const centralZoneName = zones[centralZoneIndex]; const spokeZones = zones.filter((_, index) => index !== centralZoneIndex); const numSpokes = spokeZones.length;
             const centralDiv = createZoneElement(centralZoneName); const centralIsMajor = centralDiv.classList.contains('zone-major');
             const centralElementWidth = centralIsMajor ? 160 : 120; const centralElementHeight = centralIsMajor ? 65 : 50;
             const centralX = Math.max(centralElementWidth / 2, Math.min(containerWidth - centralElementWidth / 2, centerX));
             const centralY = Math.max(centralElementHeight / 2, Math.min(containerHeight - centralElementHeight / 2 - 15, centerY));
             centralDiv.style.left = `${centralX}px`; centralDiv.style.top = `${centralY}px`; centralDiv.style.zIndex = '10';
             const centralData = { name: centralZoneName, element: centralDiv, x: centralX, y: centralY, isHub: true };
             placedZoneData.push(centralData);
             if (numSpokes > 0) {
                 const baseRadius = Math.min(containerWidth, containerHeight) * 0.32 * sizeFactor; const radiusVariation = 0.1 * sizeFactor;
                 spokeZones.forEach((zoneName, index) => {
                     const spokeDiv = createZoneElement(zoneName); const isMajor = spokeDiv.classList.contains('zone-major');
                     const elementWidth = isMajor ? 160 : 120; const elementHeight = isMajor ? 65 : 50;
                     const angle = (index / numSpokes) * 2 * Math.PI; const radius = baseRadius * (1 + (Math.random() - 0.5) * 2 * radiusVariation);
                     const targetX = centerX + radius * Math.cos(angle); const targetY = centerY + radius * Math.sin(angle);
                     const finalX = Math.max(elementWidth / 2, Math.min(containerWidth - elementWidth / 2, targetX));
                     const finalY = Math.max(elementHeight / 2, Math.min(containerHeight - elementHeight / 2 - 15, targetY));
                     spokeDiv.style.left = `${finalX}px`; spokeDiv.style.top = `${finalY}px`;
                     placedZoneData.push({ name: zoneName, element: spokeDiv, x: finalX, y: finalY, isHub: false, hubRef: centralData });
                 });
             }
             console.log("layoutHubAndSpoke finished.");
        }
        function layoutLinear(zones, containerWidth, containerHeight, options) {
            console.log("layoutLinear running...");
             const sizeFactor = options.size === 'Large' ? 0.9 : (options.size === 'Small' ? 1.05 : 1.0);
             const numZones = zones.length; if (numZones === 0) return;
             let requiredWidth = 0; const paddingBase = 30;
             zones.forEach(zoneName => { const isMajor = majorZoneKeywords.some(keyword => zoneName.toLowerCase().includes(keyword.toLowerCase())); requiredWidth += isMajor ? 160 : 120; });
             requiredWidth += Math.max(0, numZones - 1) * paddingBase * sizeFactor;
             const minPadding = 20; let currentX;
             if (requiredWidth < containerWidth - (2 * minPadding)) { currentX = (containerWidth - requiredWidth) / 2; }
             else { console.warn("Linear layout content may exceed container width."); currentX = minPadding; }
             const verticalCenter = containerHeight / 2; const verticalJitter = containerHeight * 0.1;
             zones.forEach((zoneName, index) => {
                 const zoneDiv = createZoneElement(zoneName); const isMajor = zoneDiv.classList.contains('zone-major');
                 const elementWidth = isMajor ? 160 : 120; const elementHeight = isMajor ? 65 : 50;
                 const targetX = currentX + elementWidth / 2; currentX += elementWidth + (paddingBase * sizeFactor);
                 const targetY = verticalCenter + (Math.random() - 0.5) * verticalJitter;
                 const finalY = Math.max(elementHeight / 2, Math.min(containerHeight - elementHeight / 2 - 15, targetY));
                 zoneDiv.style.left = `${targetX}px`; zoneDiv.style.top = `${finalY}px`;
                 placedZoneData.push({ name: zoneName, element: zoneDiv, x: targetX, y: finalY, index: index });
             });
             console.log("layoutLinear finished.");
        }


        // --- Helper: Select Random Elements ---
        function selectRandomElements(arr, count) { if (!arr || arr.length === 0) return []; if (count <= 0) return []; if (count >= arr.length) { let fullShuffled = [...arr]; for (let i = fullShuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [fullShuffled[i], fullShuffled[j]] = [fullShuffled[j], fullShuffled[i]]; } return fullShuffled; } let shuffled = [...arr]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled.slice(0, count); }

        // --- Draw Connections Function ---
        function drawConnections(zoneData, layoutStyle, svgElement) {
            console.log("drawConnections running...");
            if (!svgElement || zoneData.length < 2) { console.log("Not enough data or no SVG element."); return; }
            let maxX = 0, maxY = 0;
             zoneData.forEach(zd => { if (!zd || !zd.element || typeof zd.x !== 'number' || typeof zd.y !== 'number') { console.warn("Skipping invalid zone data for SVG sizing:", zd); return; } const elementWidth = zd.element.classList.contains('zone-major') ? 160 : 120; const elementHeight = zd.element.classList.contains('zone-major') ? 65 : 50; maxX = Math.max(maxX, zd.x + elementWidth / 2); maxY = Math.max(maxY, zd.y + elementHeight / 2); });
             const containerWidth = svgElement.parentNode.offsetWidth; const containerHeight = svgElement.parentNode.offsetHeight;
             const svgWidth = Math.max(containerWidth, maxX + 20); const svgHeight = Math.max(containerHeight, maxY + 20);
             svgElement.setAttribute('width', svgWidth); svgElement.setAttribute('height', svgHeight);
             console.log(`SVG dimensions set to: ${svgWidth} x ${svgHeight}`);
            const corridorConnections = new Set(); const ventConnections = new Set(); const corridorPairs = [];
            if (layoutStyle === 'Grid') { zoneData.forEach((zone1, index1) => { zoneData.forEach((zone2, index2) => { if (index1 >= index2 || !zone1 || !zone2) return; const rowDiff = Math.abs(zone1.row - zone2.row); const colDiff = Math.abs(zone1.col - zone2.col); if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) { corridorPairs.push([zone1, zone2]); } }); }); }
            else if (layoutStyle === 'HubAndSpoke') { const hub = zoneData.find(z => z && z.isHub); if (hub) { zoneData.forEach(zone => { if (zone && !zone.isHub) { corridorPairs.push([hub, zone]); } }); } }
            else if (layoutStyle === 'Linear') { for (let i = 0; i < zoneData.length - 1; i++) { if(zoneData[i] && zoneData[i+1]) { corridorPairs.push([zoneData[i], zoneData[i + 1]]); } } }
            corridorPairs.forEach(pair => { const zone1 = pair[0]; const zone2 = pair[1]; if (!zone1 || !zone2 || typeof zone1.x !== 'number' || typeof zone1.y !== 'number' || typeof zone2.x !== 'number' || typeof zone2.y !== 'number') { console.warn("Skipping corridor draw due to invalid zone data:", zone1, zone2); return; } const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', zone1.x); line.setAttribute('y1', zone1.y); line.setAttribute('x2', zone2.x); line.setAttribute('y2', zone2.y); line.setAttribute('class', 'connector-line connector-corridor'); svgElement.appendChild(line); const key = [zone1.name, zone2.name].sort().join('|'); corridorConnections.add(key); });
            console.log(`Drew ${corridorConnections.size} corridor lines.`);
            const ventPairs = []; const maxVentDistance = 300;
            zoneData.forEach((zone1, index1) => { if (!zone1 || typeof zone1.x !== 'number' || typeof zone1.y !== 'number') return; const name1Lower = zone1.name.toLowerCase(); const isTech1 = technicalKeywords.some(k => name1Lower.includes(k.toLowerCase())); const isAccess1 = name1Lower.includes('access') || name1Lower.includes('vent') || name1Lower.includes('tunnel'); if (!isTech1 && !isAccess1) return; zoneData.forEach((zone2, index2) => { if (index1 >= index2 || !zone2 || typeof zone2.x !== 'number' || typeof zone2.y !== 'number') return; const name2Lower = zone2.name.toLowerCase(); const isTech2 = technicalKeywords.some(k => name2Lower.includes(k.toLowerCase())); let shouldVent = false; const distance = Math.sqrt(Math.pow(zone1.x - zone2.x, 2) + Math.pow(zone1.y - zone2.y, 2)); if (distance < maxVentDistance) { if (isTech1 && isTech2) { shouldVent = true; } else if (isAccess1 && isTech2) { shouldVent = true; } } if (shouldVent) { const key = [zone1.name, zone2.name].sort().join('|'); if (!corridorConnections.has(key) && !ventConnections.has(key)) { ventPairs.push([zone1, zone2]); ventConnections.add(key); } } }); });
            ventPairs.forEach(pair => { const zone1 = pair[0]; const zone2 = pair[1]; if (!zone1 || !zone2 || typeof zone1.x !== 'number' || typeof zone1.y !== 'number' || typeof zone2.x !== 'number' || typeof zone2.y !== 'number') { console.warn("Skipping vent draw due to invalid zone data:", zone1, zone2); return; } const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', zone1.x); line.setAttribute('y1', zone1.y); line.setAttribute('x2', zone2.x); line.setAttribute('y2', zone2.y); line.setAttribute('class', 'connector-line connector-vent'); svgElement.appendChild(line); });
            console.log(`Drew ${ventConnections.size} vent lines.`);
            console.log("drawConnections finished.");
        }

        // --- Initial Map Generation on Load ---
        window.onload = () => {
            console.log("Window loaded. Attempting initial map generation...");
            try {
                if (generateButton) { // Ensure button exists before initial call
                     generateMap();
                } else {
                    console.warn("Generate button not found on load, skipping initial generation.");
                }
            } catch (error) {
                console.error("Error during initial map generation (onload):", error);
                 if(mapContainer) {
                     mapContainer.innerHTML = `<p style="color: red; padding: 20px;">Error on initial load: ${error.message}. Try clicking 'Generate Map'.</p>`;
                 }
            }
        };

    </script>

</body>
</html>
